# 240807수

## 진행사항

## 수업 내용_상속, 접근제한자, 객체지향의 특징

### 상속

* 부모클래스 -> 상속해주는 클래스

  부모의 멤버, 메서드를 상속을 해준다.

* 자식클래스 -> 상속받는 클래스

  다시 정의하지 않고 부모의 것을 사용할 수 있다.

```java
부모클래스
class Parent {
    
}

자식클래스
class Child extends Parent {
    
}
```

오버라이딩

* 부모에 정의된 메서드를 자식의 상황에 맞게 재정의

1. 메서드명, 반환형, 매개변수 모두 같아야 한다.
2. 내용만 달라야 한다.
3. 접근제한자는 부모의 메서드보다 좁은 범위는 가능하다.

### super

* 부모클래스에서 상속받은 필드나 메서드를 자식 클래스에서 참조하는데 사용하는 참조변수이다.
* this와 super
  * this -> 자기 자신을 참조
  * super -> 부모 객체를 상속

### 접근제한자

* 제한자

  클래스, 변수, 또는 메서드의 선언부에 함께 사용해 부가적인 의미를 부여하는 키워드

  경우에 따라 여러 개 조합하여 사용할 수 있지만, 접근 제한자의 경우 하나만 선택해서 사용해야 한다.

* 접근제한자

  클래스, 멤버(필드, 메서드)에 접근 가능한 범위를 제한하는 키워드

  객체지향 프로그래밍의 특징중 한 가지인 정보 은닉을 지키기 위한 중요한 부분이다.

  * public : 제한 없이 모든 패키지, 모든 클래스에서 접근이 가능하다.
  * protected : 같은 패키지 안에서 접근 가능하며, 다른 패키지라도 자식클래스라면 접근이 가능하다.
  * default : 같은 패키지 내에서만 접근이 가능하다.
  * private : 같은 클래스 내에서만 접근이 가능하다.

* 클래스의 접근제한자

  * 클래스는 접근제한자로 public과 default만 가질 수 있다.
  * private와 protected의 경우, 클래스 멤버들을 위한 접근제한자로 클래스 외부에서 접근을 막을지 말지에 대해 제한하는 용도로 사용되기 때문에 클래스의 접근제한자로 사용할 수 없다.
  
* default

  * 접근제한자를 따로 명시하지 않는다면 클래스와 멤버들은 자동으로 default를 가진다.
  * default로 선언된 클래스와 멤버들은 같은 패키지 안에서는 어디든지 접근 및 사용이 가능하나 다른 패키지에서는 접근이 불가능하다.
  
* protected

  * 클래스 멤버를 위한 제한자로, 상속과 관련이 있는 제한자이다.
  * default처럼 같은 패키지 안에서 접근과 사용을 허가하지만, 다른 패키지에서의 접근을 완전히 제한하는 것이 아닌 "해당 클래스와 상속관계에 있는 자식 클래스"라면 다른 패키지라도 접근 및 사용이 가능하다.

* private

  * 가장 사용 범위가 좁은 클래스 멤버를 위한 제한자이다.
  * 클래스가 public/default이더라도, private으로 선언된 멤버들은 클래스 외부에서 접근이 불가능하다.
  * 오직 선언된 클래스 내부에서만 접근하여 사용할 수 있다.

### 객체지향의 특징

* 캡슐화(getter & setter)

  * 객체 내부의 멤버(필드, 메서드 등)를 객체 외부에서 볼 수 없도록 캡슐화 한다.

  * 접근이 필요한 경우 public 메서드를 활용해 접근하고, 이외의 값들은 모두 캡슐화를 통해 정보를 은닉한다.
* 상속

  * 미리 정의된 부모 클래스의 멤버를 자식 클래스가 물려받는다.
* 다형성

  * 하나의 방법으로 여러 객체를 호출하여 사용할 수 있다.
* 추상화

  * 공통된 기능과 정보를 추출해 객체화 한다.

### N차 상속

* 상속을 그 다음세대에도 넘길 수 있다.
* 2차, 3차, ... N차까지 원하는만큼 상속을 이어받을 수 있다.

### Final

* final 키워드는 상수를 뜻하는 키워드로 필드 앞에 선언하여 사용한다.

* 초기화 후 값을 바꿀 수 없으며 시간이 지나도 처음 정의된 상태가 변하지 않는다는 의미를 가지고 있다.

* 이 키워드는 메서드와 클래스에도 사용할 수 있다.

* final 클래스

  클래스 앞에 final을 추가할 경우, 이 클래스는 상속의 마지막 클래스임을 뜻한다.

* 어떠한 클래스도 이 클래스 자식 클래스가 될 수 없고, 자연스럽게 이 클래스는 어떠한 클래스의 부모클래스도 될 수 없다.

### final 메서드

* 메서드 앞에 final을 추가하게 되면 상속은 받더라도, 오버라이딩 할 수 없는 메서드가 된다.
* 즉, 자식 클래스더라도 부모클래스에 final로 선언된 메서드는 자식클래스에서 오버라이딩 하지 못하고 있는 그대로 사용해야 한다.
* 생성자에는 final을 붙힐 수 없다.
  * 생성자는 접근제한자만 추가할 수 있다.
  * 따라서 클래스를 final로 선언하더라도 생성자를 final로 선언할 수 없다.

### 클래스에서의 타입변환

* 타입변환은 타입을 다른 타입으로 변환하는 것
* 자바에서는 다음과 같이 두 가지 타입변환이 있다.
  * 자료형 변환
  * 클래스의 객체 타입 변환
* 클래스의 타입변환도 마찬가지로 자동 타입변환과 강제 타입변환이 있다.
* 단, 자료형에 비해 타입 변환이 가능한 범위가 상당히 좁다.
* 클래스의 타입 변환은, 서로 상속 관계에 있는 클래스 사이에서만 변환할 수 있다.

### 클래스의 자동 타입 변환

* 자료형에서의 자동 형 변환과 마찬가지로 개발자가 직접 명시하지 않아도 자동으로 타입변환이 일어나는 것을 '클래스 자동 타입 변환'이라고 한다.
* 클래스 자동 타입 변환은 상속 관계에 있는 자식 클래스의 객체를 부모타입으로 변환하는것을 말한다.
* 부모타입 변수명 = new 자식클래스명();
* 이미 만들어진 자식 객체를 부모 타입으로 변환하려고 할 때는 다음과 같이 쓴다.
* 부모타입 변수명 = 자식객체변수명;

## Memo

* hw

  Car 클래스는 gasGauge필드를 갖고 있고, 생성자를 통해 초기화한다.
  가스잔여량을 출력하는 함수인 showCurrentGauge()를 갖고 있다.

  HybridCar 클래스는 electricGauge변수를 갖고 있고, Car 클래스를 상속하고 생성자를 생성할 때
  gasGauge,electricGauge를 파라미터로 받는다.
  메서드는 오버라이딩을 이용하여 잔여 가스와 잔여 전기량을 출력

  HybridWaterCar 클래스는 waterGauge변수를 갖고 있고, HybridCar 클래스를 상속받는다.
  생성자 생성할 때는 gasGauge,electricGauge,waterGauge를 파라미터로 받는다.
  메서드 오버라이딩을 이용하여 잔여 가스와 잔여 전기량, 잔여 물량 출력

  main에서 HybridWaterCar 객체를 생성하여 다음과 같은 결과를 출력하시오.

  잔여 가스량 : 15
  잔여 전기량 : 30
  잔여 물량 : 25

  *Car.java*

  ```java
  package ex01_super;
  
  // 클래스에 들어갈 수 있는 것
  // 1. 필드
  // 2. 메서드
  // 3. 생성자
  
  public class Car {
  
  	// 필드
  	int gasGauge;
  	
  	// 생성자
  	// 접근제한자 클래스명(매개변수) {
  	// 
  	// }
  	
  	public Car(int gasGauge) {
  		this.gasGauge = gasGauge;
  		// this : 자기자신
  	}
  	
  	// 메서드
  	// 접근제한자 반환형 메서드명(매개변수) {
  	//
  	//}
  	
  	public void showCurrentGauge() {
  		System.out.println("가스량 : " + this.gasGauge);
  	}
  	
  }
  ```

  *HybridCar.java*

  ```java
  package ex01_super;
  
  public class HybridCar extends Car {
  	int electricGauge;
  	
  	public HybridCar(int gasGauge, int electricGauge) {
  		super(gasGauge); 
  		// 매개변수 gasGauge를 super를 통해 부모 클래스로 전달
  		this.electricGauge = electricGauge;
  	}
  	
  	// 메서드는 오버라이딩을 이용하여 잔여 가스와 잔여 전기량을 출력
  	@Override
  	public void showCurrentGauge() {
  		super.showCurrentGauge(); // 부모클래스의 메서드 실행
  		System.out.println("전기량 : " + electricGauge);
  	}
  }
  ```

  *HybridWaterCar.java*

  ```java
  package ex01_super;
  
  public class HybridWaterCar extends HybridCar {
  	
  	int waterGauge;
  	
  	public HybridWaterCar(int gasGauge, int electricGauge, int waterGauge) {
  		super(gasGauge, electricGauge);
  		this.waterGauge = waterGauge;
  	}
  	
  	@Override
  	public void showCurrentGauge() {
  		super.showCurrentGauge();
  		System.out.println("물의 양 : " + waterGauge);
  	}
  }
  ```

  *CarMain.java*

  ```java
  package ex01_super;
  
  public class CarMain {
  	public static void main(String[] args) {
  		HybridWaterCar hwc = new HybridWaterCar(15, 30, 25);
  		hwc.showCurrentGauge();
  	}
  }
  ```

